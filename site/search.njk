---
layout: layouts/base.njk
title: Search
description: "Find articles, authors, and topics across the publication."
permalink: /search/
---
{% from "components/search-form.njk" import searchForm %}
{% from "components/search-results.njk" import searchResults %}
<section class="search-page">
  <header class="search-page__header">
    <h1>Search</h1>
    <p>Discover articles, authors, and topics across the publication.</p>
  </header>
  {{ searchForm({ id: 'search-page-input', initial: '', showHint: true }) | safe }}
  {{ searchResults({ loading: true, query: '' }) | safe }}
</section>

{% block scripts %}
  <script src="/assets/vendor/minisearch.js" defer></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const container = document.querySelector('.search-page');
      if (!container) return;
      const MiniSearch = window.MiniSearch;
      if (!MiniSearch) return;
      const form = container.querySelector('[data-search-form]');
      const input = container.querySelector('[data-search-input]');
      const clearBtn = container.querySelector('[data-search-clear]');
      const list = container.querySelector('[data-search-list]');
      const meta = container.querySelector('[data-search-meta]');
      const empty = container.querySelector('[data-search-empty]');
      const countNode = container.querySelector('[data-search-count]');
      const queryNode = container.querySelector('[data-search-query]');
      const pluralNode = container.querySelector('[data-search-plural]');
      const loadingIndicator = container.querySelector('[data-search-results] .loading-indicator');
      const setLoading = (state) => {
        if (!loadingIndicator) return;
        loadingIndicator.hidden = state ? false : true;
      };
      const params = new URLSearchParams(window.location.search);
      if (input && params.get('q')) {
        input.value = params.get('q');
      }

      let mini = null;
      let docs = [];
      let loading = false;
      let allResults = [];
      let currentQuery = '';
      let currentPage = 1;
      const pageSize = 10;
      const analyticsKey = 'search-stats';

      const debounce = (fn, delay = 300) => {
        let timer = null;
        const debounced = (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => fn(...args), delay);
        };
        debounced.cancel = () => clearTimeout(timer);
        return debounced;
      };

      const updateAnalytics = (query) => {
        if (!query) return;
        try {
          const raw = window.localStorage.getItem(analyticsKey);
          const stats = raw ? JSON.parse(raw) : { total: 0, queries: {} };
          stats.total += 1;
          stats.queries[query] = (stats.queries[query] || 0) + 1;
          window.localStorage.setItem(analyticsKey, JSON.stringify(stats));
        } catch (error) {
          console.warn('Search analytics unavailable', error);
        }
      };

      const highlightText = (text, terms) => {
        if (!text || !terms.length) return text;
        const escapedTerms = terms.map((term) => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
        const regex = new RegExp(`(${escapedTerms.join('|')})`, 'gi');
        return text.replace(regex, '<mark>$1</mark>');
      };

      const updateUrl = (query) => {
        const url = new URL(window.location.href);
        if (query) {
          url.searchParams.set('q', query);
        } else {
          url.searchParams.delete('q');
        }
        window.history.replaceState(null, '', url);
      };

      const renderList = (results) => {
        if (!list) return;
        list.innerHTML = '';
        results.forEach((result) => {
          const li = document.createElement('li');
          li.className = 'search-results__item';
          const article = document.createElement('article');
          article.className = `search-result search-result--${result.type}`;
          const header = document.createElement('header');
          header.className = 'search-result__header';
          const type = document.createElement('p');
          type.className = 'search-result__type';
          type.textContent = result.type.charAt(0).toUpperCase() + result.type.slice(1);
          const title = document.createElement('h2');
          title.className = 'search-result__title';
          title.innerHTML = result.title;
          header.append(type, title);
          article.append(header);
          if (result.subtitle) {
            const excerpt = document.createElement('p');
            excerpt.className = 'search-result__excerpt';
            excerpt.innerHTML = result.subtitle;
            article.append(excerpt);
          }
          const footer = document.createElement('footer');
          footer.className = 'search-result__meta';
          if (result.author) {
            const span = document.createElement('span');
            span.textContent = result.author;
            footer.append(span);
          }
          if (result.tags) {
            const span = document.createElement('span');
            span.textContent = `#${result.tags}`;
            footer.append(span);
          }
          article.append(footer);
          const link = document.createElement('a');
          link.className = 'search-result__link';
          link.href = result.url;
          link.setAttribute('aria-label', `View ${result.title.replace(/<[^>]+>/g, '')}`);
          article.append(link);
          li.append(article);
          list.append(li);
        });
      };

      const renderPage = () => {
        const total = allResults.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        const start = (currentPage - 1) * pageSize;
        const pageResults = allResults.slice(start, start + pageSize);
        if (queryNode) queryNode.textContent = currentQuery;
        if (countNode) countNode.textContent = total;
        if (pluralNode) pluralNode.toggleAttribute('hidden', total === 1 || total === 0);
        if (meta) meta.hidden = !currentQuery;
        if (empty) empty.hidden = total !== 0 || !currentQuery;
        if (pagination) {
          pagination.hidden = total <= pageSize;
          if (prevBtn) prevBtn.disabled = currentPage === 1;
          if (nextBtn) nextBtn.disabled = currentPage === totalPages;
          if (pageLabel) pageLabel.textContent = `Page ${currentPage} of ${totalPages}`;
        }
        renderList(pageResults);
      };

      const renderResults = (results, query) => {
        allResults = results;
        currentQuery = query;
        currentPage = 1;
        renderPage();
      };

      const performSearch = (query) => {
        if (!mini || !query) {
          meta.hidden = true;
          empty.hidden = true;
          list.innerHTML = '';
          return;
        }
        setLoading(false);
        const terms = query.split(/\s+/u).filter(Boolean);
        const matches = mini.search(query, {
          prefix: true,
          fuzzy: 0.2,
          combineWith: 'AND'
        }).map((result) => {
          const doc = docs.find((doc) => doc.id === result.id) || {};
          return {
            ...result,
            title: highlightText(result.title || doc.title || '', terms),
            subtitle: highlightText(result.subtitle || doc.subtitle || '', terms),
            tags: doc.tags || '',
            author: doc.author || result.author
          };
        });
        meta.hidden = false;
        empty.hidden = matches.length !== 0;
        setLoading(false);
        renderResults(matches, query);
        updateAnalytics(query);
        updateUrl(query);
      };

      const debouncedSearch = debounce((query) => performSearch(query));

      const loadIndex = async () => {
        if (loading || mini) return;
        loading = true;
        try {
          const [indexRes, docsRes] = await Promise.all([
            fetch('/search-index.json'),
            fetch('/search-docs.json')
          ]);
          const indexJson = await indexRes.json();
          docs = await docsRes.json();
          mini = MiniSearch.loadJSON(indexJson, {
            fields: ['title', 'subtitle', 'content', 'tags', 'author'],
            storeFields: ['title', 'subtitle', 'type', 'url', 'tags', 'author']
          });
          setLoading(false);
          if (input && input.value.trim()) {
            performSearch(input.value.trim());
          }
        } catch (error) {
          console.error('Failed to load search index', error);
          const alert = document.createElement('div');
          alert.className = 'alert';
          alert.textContent = 'Search is unavailable at the moment. Please try again later.';
          list.replaceWith(alert);
          setLoading(false);
        } finally {
          loading = false;
        }
      };

      if (form && input) {
        form.addEventListener('submit', (event) => {
          event.preventDefault();
          debouncedSearch.cancel?.();
          setLoading(true);
          performSearch(input.value.trim());
        });

        input.addEventListener('input', () => {
          const value = input.value.trim();
          if (!value) {
            meta.hidden = true;
            empty.hidden = true;
            list.innerHTML = '';
            updateUrl('');
            if (pagination) pagination.hidden = true;
            setLoading(false);
            return;
          }
          setLoading(true);
          debouncedSearch(value);
        });

        clearBtn?.addEventListener('click', () => {
          input.value = '';
          meta.hidden = true;
          empty.hidden = true;
          list.innerHTML = '';
          updateUrl('');
          if (pagination) pagination.hidden = true;
          setLoading(false);
          input.focus();
        });
      }

      prevBtn?.addEventListener('click', () => {
        if (currentPage <= 1) return;
        currentPage -= 1;
        renderPage();
      });

      nextBtn?.addEventListener('click', () => {
        const totalPages = Math.max(1, Math.ceil(allResults.length / pageSize));
        if (currentPage >= totalPages) return;
        currentPage += 1;
        renderPage();
      });

      loadIndex().then(() => {
        if (form && input && input.value.trim()) {
          performSearch(input.value.trim());
        } else {
          setLoading(false);
        }
      });
    });
  </script>
{% endblock %}
